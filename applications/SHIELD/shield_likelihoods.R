# In the census manager: 
# anywhere that we have a county level data, we should have a national level data with the same stratification and ontology names 
# anywhere that we have a MSA level data, we should have a national level data with the same stratification and ontology names
# we can have more national level estimates if we can pull them directly 
# in the surveillance manager, we only need to have MSA level and national level data
# we should bound agegroups at 85+
source("applications/SHIELD/shield_historical_likelihood_penalty_helper.R")

# STAGE.0: Demographic calibration
# STAGE.1: Diagnosis (race, sex stratified) - demog
# STAGE.2: Diagnosis (race, sex, age stratified) - demog
# WEIGHTS: The weights are used to weaken the likelihoods for better mixing 
TOTAL.WEIGHT=1/8
STAGE.0.POP.WEIGHT= 1/16 #'@ryan: to add
STAGE.0.TD.WEIGHT= 1/16 #total diagnosis  #'@ryan: to add
EL.DIAGNOSIS.WEIGHT = TOTAL.WEIGHT 
POPULATION.WEIGHT = STAGE.0.POP.WEIGHT
DIAGNOSIS.WEIGHT = TOTAL.WEIGHT
TESTING.WEIGHT = TOTAL.WEIGHT
PRENATAL.WEIGHT = TOTAL.WEIGHT
PENALTY.WEIGHT = TOTAL.WEIGHT

# Population weights: 
# the census runs population count every 10 years (Decennial Census), including 2010 and 2020.
# Annual population counts (e.g., 2011, 2012, … 2019, 2021, 2022, etc.) come from the Population Estimates Program (PEP).
# These annual estimates are generated by applying the Demographic Cohort Component Method:
# population = population + births - deaths + net migration
# The annual estimates are calibrated to decennial census counts (e.g., 2011 is tied to 2010).
# so we have more faith in Decennial census than annual estiamtes and reflect this in weights:
w1=lapply(2010:2019, function(year){
    total.weight = 0.95^(year-2010)
    create.likelihood.weights(total.weight,dimension.values = list(year=year))
})
w2=lapply(2020:2023, function(year){
    total.weight = 0.95^(year-2020)
    create.likelihood.weights(total.weight,dimension.values = list(year=year))
})
w.population <- lapply(c(w1,w2), function(wi) {
    create.likelihood.weights(
        total.weight = POPULATION.WEIGHT * wi$total.weight,
        dimension.values = wi$dimension.values,
        is.recursive = wi$is.recursive
    )
})


#** POPULATION SIZES ** ---- 
#'@PK: what is the logic, where are the assumptions from?
#'# Error variance for population data <From EHE model>
population.error.sd.shield = function(data, details=attr(data, 'details'), version, location)
{
    melted.data = reshape2::melt(data)
    years.since.preceding.census = melted.data$year %% 10
    years.from.nearest.census = pmin(years.since.preceding.census, -melted.data$year %% 10)
    # Set up error terms
    inherent.census.cv = 0.015
    
    stratified.dimension.candidates = c('age','race','sex')
    n.stratified.dimensions = length(intersect(names(dim(data)), stratified.dimension.candidates))
    
    if (n.stratified.dimensions<=1)
        max.post.censal.cv = 0.1561269 #from calculating_error_terms_for_ehe_likelihoods.R
    else
        max.post.censal.cv = 0.1939618
    
    max.post.censal.var = inherent.census.cv^2 + max.post.censal.cv^2
    
    post.censal.cv = exp(log(inherent.census.cv) + years.since.preceding.census * (0.5*log(max.post.censal.var) - log(inherent.census.cv)) / 9)
    WEIGHT.TO.INTERCENSAL.VS.POSTCENSAL = 4
    intercensal.cv = exp(log(inherent.census.cv) + years.from.nearest.census * (0.5*log(max.post.censal.var / WEIGHT.TO.INTERCENSAL.VS.POSTCENSAL) - log(inherent.census.cv)) / 9)
    
    # this is a hack now - need to talk to Zoe about how she will formulate the details field
    # I just know that totals are intercensal at this time
    is.intercensal = grepl('intercensal', details, ignore.case = TRUE) | n.stratified.dimensions==0
    cv = post.censal.cv
    cv[is.intercensal] = intercensal.cv
    
    data * cv
}
population.likelihood.instructions = 
    create.basic.likelihood.instructions(outcome.for.sim = "population",
                                         outcome.for.data = "population", 
                                         na.rm =T,
                                         dimensions = c("age","sex","race"),
                                         levels.of.stratification = c(0,1,2), # 0 = totals, 1 = 1-way stratification (e.g., age), 2 = 2-way stratification (e.g., age race)
                                         from.year = 2010, # the year calibration starts (population size and demographics are fix to 2007)
                                         
                                         # ERROR VARIANCE: describes how precise the estimates are; # e.g., estimates can be off by X% each year
                                         error.variance.type = 'function.sd',
                                         error.variance.term = population.error.sd.shield, 
                                         
                                         #CORRELATION STRUCTURE: if census data is off in one year, how much is it off the next year or different strata?
                                         observation.correlation.form = 'autoregressive.1', # errors in consecutive time periods are more strongly correlated, but this correlation weakens over time
                                         #
                                         correlation.different.years = 0.5, # default #'@PK
                                         correlation.different.strata = 0.1, # default #'@PK
                                         # correlation.different.sources = 0, # default  
                                         correlation.same.source.different.details = 0.3, # default: 
                                         
                                         # WEIGHTS: higher weights for decennial counts and lower for annual estimates: 
                                         weights = w.population, #above
                                         equalize.weight.by.year = F # if set to true: it'll down-weight years with more data points
                                         # to balance with those years where we have fewer data points
    )

#** DEATHS **  ----
#*For county & MSAs: only available Total (2011-2023)
#*For national: also available by age, race/eth, sex (2001-2020)
deaths.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "deaths",
                                         outcome.for.data = "deaths", 
                                         levels.of.stratification = c(0), 
                                         from.year = 2010, 
                                         #
                                         error.variance.type = 'function.sd',
                                         error.variance.term = population.error.sd.shield, 
                                         #
                                         observation.correlation.form = 'compound.symmetry', 
                                         #
                                         weights = POPULATION.WEIGHT ,
                                         na.rm =T
    )

#** FETILITY RATE **  ----
# For county; MSA; national data available by age & race (2007-2023)
fertility.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "fertility.rate",
                                         outcome.for.data = "fertility.rate",  
                                         dimensions = c("age","race"),
                                         levels.of.stratification = c(0,1,2), 
                                         from.year = 2007,  #data available from 2007-2023
                                         #
                                         error.variance.type = 'function.sd',
                                         error.variance.term = population.error.sd.shield,  
                                         #
                                         observation.correlation.form = 'compound.symmetry',
                                         #
                                         weights = POPULATION.WEIGHT ,
                                         na.rm =T
    )

#** MIGRATION **  ----
#* data is available for 6 overlapping 5-year period (2011-2015, 2012-2016, ....)
#* one way stratifiation (by age, by race, by sex) is only available for 2011-2015
immigration.likelihood.instructions = 
    create.basic.likelihood.instructions(outcome.for.sim = "immigration",
                                         outcome.for.data = "immigration", 
                                         dimensions = c('age','race','sex'),
                                         levels.of.stratification = c(0,1),
                                         from.year = 2011, 
                                         to.year=2020,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.13, # using MOEs from data - see migration_MOE_summary #'@PK
                                         #
                                         observation.correlation.form = 'compound.symmetry',
                                         #
                                         weights = POPULATION.WEIGHT ,
                                         equalize.weight.by.year = T,  #'@Ryan: do we need this? 
                                         na.rm =T
    )

emigration.likelihood.instructions = 
    create.basic.likelihood.instructions( outcome.for.sim = "emigration",
                                          outcome.for.data = "emigration", 
                                          dimensions = c("age","race"), 
                                          levels.of.stratification = c(0,1,2),
                                          from.year = 2011, 
                                          to.year=2020,
                                          #
                                          error.variance.type = 'cv',
                                          error.variance.term = 0.13, # using MOEs from data - see migration_MOE_summary #'@PK
                                          #
                                          observation.correlation.form = 'compound.symmetry',
                                          #
                                          weights = POPULATION.WEIGHT ,
                                          equalize.weight.by.year = T,  #'@Ryan: do we need this? 
                                          na.rm =T
    )


#** SYPHILIS DIAGNOSIS ** ----
## Total Diagnosis----
##---- Historical Penalty ----
#using national level data on total diagnosis, we estimated the min and max value of the ratio between annual diagnosis relative to the peak in 1990
# for each year between 1970-1990 in the model, we calculate a similar ratio and bound the values to fall within this min/max threshold (to align with national trend)
# if the values fall below min, we penalize the likelihood by dlnorm. 
# if they fall between min and max, they likelihood is 1
# if the value falls over max, we penalize it by dlnorm
historical.diagnosis.likelihood.instructions <-
    create.custom.likelihood.instructions(
        name = "historical.diagnosis.likelihood",
        compute.function = function(sim, data, log = T) {
            vals  <- sim$optimized.get(data$get.instr) #get simulated values
            years <- data$years #get years
            # ratio of total diagnosis from 1970-1989 to diagnosis in 1990:
            idx1990  <- which(years == 1990)
            peak_1990 <- vals[idx1990]
            ratio <- vals[1:(idx1990-1)]/peak_1990
            #
            # unpack two nationa thresholds:
            min_r   <-  data$min.ratio
            max_r   <-  data$max.ratio  
            σ_low   <- log(2)/2      # tune: how sharply to punish below 1/2 1990 val
            σ_high  <- log(2)/2      # tune: how sharply to punish too-spiky
            #
            # piecewise penalty
            logp_annual = 0 #by default
            #
            total.logp = lapply(ratio, function(r){
                # if fall below min threshold: penalize with a lognormal centered at min_r
                if (r  < min_r) {
                    μ_low <- log(min_r)
                    logp_annual  <- dlnorm(r, meanlog = μ_low, sdlog = σ_low, log = TRUE)
                }
                # if fall over max threshold:  penalize with a lognormal centered at max_r
                if (r > max_r) {
                    μ_high <- log(max_r)
                    logp_annual   <- dlnorm(r, meanlog = μ_high, sdlog = σ_high/sqrt(PENALTY.WEIGHT), log = TRUE)
                }
                #
                logp_annual
            })
            #
            total.logp = sum(unlist(total.logp))
            if (log) total.logp else exp(total.logp)
        },
        get.data.function = function(version, location) {
            sim.meta <- get.simulation.metadata(version = version, location = location)
            #
            # instruction to fetch your outcome over time
            get.instr <- sim.meta$prepare.optimized.get.instructions(
                outcome             = "diagnosis.total",
                dimension.values          = list(year = seq(1970, 1990)),
                keep.dimensions           = "year",
                drop.single.sim.dimension = TRUE
            )
            #
            # supply the historical vectors and computed params
            list(
                get.instr       = get.instr,
                years           = hist_df$year,
                national.values = hist_df$value,
                max.ratio    = max_ratio_hist,
                min.ratio   = min_ratio_hist,
                sdlog           = sdlog_hist
            )
        }
    )

##---- Overall 1993-2022 ----
total.diagnosis.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.total",
                                         outcome.for.data = "total.syphilis.diagnoses",  
                                         levels.of.stratification = c(0),
                                         from.year = 1993,
                                         to.year = 2022,
                                         #
                                         error.variance.type = c('cv', 'sd'),
                                         error.variance.term = list(0.0764791209420945, 10),  #@Ryan: can you please cite the reference code here and clean up that coe and include dcumentation 
                                         #
                                         observation.correlation.form = 'autoregressive.1', #long timeframe
                                         #
                                         weights = DIAGNOSIS.WEIGHT ,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1 #
    )
##---- Strata Stage1 2019-2022----
total.diagnosis.by.strata.stage1.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.total",
                                         outcome.for.data = "total.syphilis.diagnoses",  
                                         levels.of.stratification = c(0,1,2),
                                         dimensions = c("sex","race"),
                                         from.year = 2019,
                                         to.year = 2022,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.0764791209420945,  
                                         #
                                         observation.correlation.form = 'compound.symmetry', #short timeframe
                                         #
                                         weights = DIAGNOSIS.WEIGHT ,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1 
    )
##---- Strata Stage2 2019-2022 ----
total.diagnosis.by.strata.stage2.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.total",
                                         outcome.for.data = "total.syphilis.diagnoses",  
                                         levels.of.stratification = c(0,1,2),
                                         dimensions = c("sex","race","age"),
                                         from.year = 2019,
                                         to.year = 2022,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.0764791209420945,   
                                         #
                                         observation.correlation.form = 'compound.symmetry',  #short timeframe
                                         #
                                         weights = DIAGNOSIS.WEIGHT ,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1 
    )



## PS Diagnosis----
# data from 1941-2022 (cdc.pdf.report) for national model Only (total)
# data from 1994-1999 (cdc.pdf.report) for national model Only (by race, agegroup, sex)
# data from 2000-2023 (cdc.sti) for county; state; national level (total; sex; race; age group; age group+sex; age group + race; race+sex)
# data from 2000-2023 (cdc.sti) for state & national (by race, agegroup, sex)
#
# data from 1993-1999 (cdc.pdf.report) for MSA and national (total, sex)
# data from 1998-2023 for MSA level (cdc.sti) for MSA (total)
# data from 2000-2023 for MSA level (cdc.sti) for MSA (total; sex; race; age group)
# data from 2000-2023 for MSA level (cdc.sti) for MSA (age group+sex; age group + race; race+sex)

##---- Overall 1993-2022 ----
ps.diagnosis.total.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.ps", 
                                         outcome.for.data = "ps.syphilis.diagnoses",  
                                         levels.of.stratification = c(0), 
                                         from.year = 1993,
                                         to.year = 2022,
                                         #
                                         error.variance.type = c('cv', 'sd'),
                                         error.variance.term = list(0.0764791209420945, 10),  
                                         #
                                         observation.correlation.form = 'autoregressive.1',
                                         #
                                         weights = DIAGNOSIS.WEIGHT,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1  
    )
##---- Strata Stage1 2019-2022 ----
ps.diagnosis.by.strata.stage1.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.ps", 
                                         outcome.for.data = "ps.syphilis.diagnoses",  
                                         dimensions = c("sex","race"),
                                         levels.of.stratification = c(0,1,2),
                                         from.year = 2019,
                                         to.year = 2022,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.0764791209420945,  
                                         #
                                         observation.correlation.form = 'compound.symmetry', #short timeframe
                                         #
                                         weights = DIAGNOSIS.WEIGHT ,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1  
    )
##---- Strata Stage2 2019-2022 ----
ps.diagnosis.by.strata.stage2.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.ps", 
                                         outcome.for.data = "ps.syphilis.diagnoses",  
                                         dimensions = c("age","race","sex"),
                                         levels.of.stratification = c(0,1,2),
                                         from.year = 2019,
                                         to.year = 2022,
                                         #
                                         error.variance.type = c('cv', 'sd'),
                                         error.variance.term = list(0.0764791209420945, 10),  
                                         #
                                         observation.correlation.form = 'compound.symmetry', #short timeframe
                                         #
                                         weights = DIAGNOSIS.WEIGHT ,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1   
    )

##---- Future Penalty ----
future.change.likelihood.instructions =
    create.custom.likelihood.instructions(
        name = "future.change.likelihood",
        compute.function = function(sim, data, log = TRUE) {
            
            get.instr   = data$get.instr
            years       = data$years
            start_year  = data$start_year
            end_year    = data$end_year
            window_len  = data$window_len
            meanlog     = data$meanlog 
            sdlog       = data$sdlog 
            sd.width   = data$sd.width             # ±2 SD band (ln space)
            weight =  data$weight
            
            
            vals  <- sim$optimized.get(get.instr)
            years <- years
            
            # rolling 5-yr ratios
            ratio <- vals / dplyr::lag(vals, window_len)
            ratio <- ratio[names(ratio) %in% as.character(years)]
            
            # use windows whose *start* year >= 2020 and *end* year <= 2030
            use <- years >= (start_year + window_len) &
                years <=  end_year &
                is.finite(ratio) & (ratio > 0)
            
            if (!any(use)) return(if (log) 0 else 1)
            
            ratio <- ratio[use]
            
            
            
            # band edges on the ratio scale corresponding to μ ± k·σ in ln-space
            lo <- exp(meanlog - sd.width*sdlog)
            hi <- exp(meanlog + sd.width*sdlog)
            
            # make the penalty 0 at the band edges 
            lp_lo <- dlnorm(lo, meanlog = meanlog, sdlog = sdlog, log = TRUE)
            lp_hi <- dlnorm(hi, meanlog = meanlog, sdlog = sdlog, log = TRUE)
            
            pen <- numeric(length(ratio))
            below <- ratio < lo
            above <- ratio > hi
            if (any(below)) pen[below] <- dlnorm(ratio[below], meanlog = meanlog, sdlog = sdlog, log = TRUE) - lp_lo
            if (any(above)) pen[above] <- dlnorm(ratio[above], meanlog = meanlog, sdlog = sdlog, log = TRUE) - lp_hi
            # inside [lo, hi] => 0
            #inverse variance weighting (to reflect how uncertainty in the underlying data reflects in the penalty we pay for each city)
            ivar <- 1 / (sdlog^2)
            w    <- weight * ivar
            total.logp <- w*sum(pen, na.rm = TRUE)   # ≤ 0; more negative = stronger penalty
            if (log) total.logp else exp(total.logp)
        },
        
        get.data.function = function(version, location) {
            sim.meta <- get.simulation.metadata(version = version, location = location)
            
            start_year  <- 2018L 
            end_year    <- 2030L
            window_len  <- 5L
            # need years 2020..2030 so t=2025..2030 ratios are computable
            years <- seq(start_year, end_year)
            
            get.instr <- sim.meta$prepare.optimized.get.instructions(
                outcome                   = "diagnosis.ps",
                dimension.values          = list(year = years),
                keep.dimensions           = "year",
                drop.single.sim.dimension = TRUE
            )
            
            list(
                get.instr   = get.instr,
                years       = years,
                start_year  = start_year,
                end_year    = end_year,
                window_len  = window_len,
                meanlog     = 0.522, # hard coded for years 2012 - 2022
                sdlog       = 0.357,
                sd.width   = 2,
                weight = PENALTY.WEIGHT  
            )
        }
    )


future.change.strata.likelihood.instructions =
    create.custom.likelihood.instructions(
        name = "future.change.5y.strata.counts",
        
        compute.function = function(sim, data, log = TRUE) {
            get.instr  <- data$get.instr
            years      <- data$years
            start_year <- data$start_year
            end_year   <- data$end_year
            h          <- data$window_len       # = 5
            meanlog    <- data$meanlog
            sdlog      <- data$sdlog
            sd.width   <- data$sd.width         # ±k·sd band (ln space)
            weight     <- data$weight
            min_count  <- data$min_count
            
            # vals expected dims: [year, sex, race] in counts
            vals <- sim$optimized.get(get.instr)
            
            # Ensure YEAR is first dimension
            dn <- names(dimnames(vals))
            year_idx <- match("year", dn)
            if (!is.na(year_idx) && year_idx != 1L) {
                ord <- c(year_idx, setdiff(seq_along(dn), year_idx))
                vals <- aperm(vals, ord)
                dn <- dn[ord]
            }
            
            # Per (sex,race) time-series penalty on 5y backward ratio of COUNTS
            per_vec_pen <- function(v, yrs) {
                v <- as.numeric(v); names(v) <- yrs
                
                R1 <- v / dplyr::lag(v, h)              
                
                v_lag <- dplyr::lag(v, h)
                use <- yrs >= (start_year + h) &
                    yrs <=  end_year &
                    is.finite(R1) & (R1 > 0) &
                    is.finite(v) & is.finite(v_lag) &
                    (v >= min_count) & (v_lag >= min_count)
                
                if (!any(use)) return(0)
                R1 <- R1[use]
                
                # Lognormal band edges on R1 scale; zero penalty at edges
                lo <- exp(meanlog - sd.width*sdlog)
                hi <- exp(meanlog + sd.width*sdlog)
                lp_lo <- dlnorm(lo, meanlog = meanlog, sdlog = sdlog, log = TRUE)
                lp_hi <- dlnorm(hi, meanlog = meanlog, sdlog = sdlog, log = TRUE)
                
                pen <- numeric(length(R1))
                below <- R1 < lo; above <- R1 > hi
                if (any(below)) pen[below] <- dlnorm(R1[below], meanlog, sdlog, log = TRUE) - lp_lo
                if (any(above)) pen[above] <- dlnorm(R1[above], meanlog, sdlog, log = TRUE) - lp_hi
                
                sum(pen, na.rm = TRUE)
            }
            
            # Sum penalties over sex×race strata (if present)
            margin_idx <- match(c("sex","race"), dn, nomatch = 0L)
            margin_idx <- margin_idx[margin_idx > 0L]
            
            total_pen <-
                if (length(margin_idx) == 0L) {
                    per_vec_pen(drop(vals), years)
                } else {
                    sum(apply(vals, margin_idx, per_vec_pen, yrs = years), na.rm = TRUE)
                }
            
            # Inverse-variance weighting (same as your other likelihoods)
            ivar <- 1 / (sdlog^2)
            w    <- weight * ivar
            total.logp <- w * total_pen
            if (log) total.logp else exp(total.logp)
        },
        
        get.data.function = function(version, location) {
            sim.meta   <- get.simulation.metadata(version = version, location = location)
            
            start_year <- 2020L     # pick your window; must allow t-1 within range #'@ryan: we should revise to 2018 so the penalty starts in 2023
            end_year   <- 2030L
            window_len <- 5L
            years      <- seq(start_year, end_year)
            
            get.instr <- sim.meta$prepare.optimized.get.instructions(
                outcome                   = "diagnosis.ps",            # COUNTS
                dimension.values          = list(year = years),
                keep.dimensions           = c("year","sex","race"),    # stratified
                drop.single.sim.dimension = TRUE
            )
            
            list(
                get.instr   = get.instr,
                years       = years,
                start_year  = start_year,
                end_year    = end_year,
                window_len  = window_len,
                meanlog     =  0.522,   
                sdlog       =  0.357,   
                sd.width    =  2,
                weight      = PENALTY.WEIGHT,
                min_count   = 30L
            )
        }
    )


U.turn.likelihood.instructions =
    create.custom.likelihood.instructions(
        name = "U.turn.likelihood",
        compute.function = function(sim, data, log = TRUE) {
            
            get.instr  <- data$get.instr
            years      <- data$years
            start_year <- data$start_year
            end_year   <- data$end_year
            h          <- data$window_len        # = 5
            meanlog    <- data$meanlog
            sdlog      <- data$sdlog
            Q25        <- data$Q25 
            Q75        <- data$Q75    
            weight     <- data$weight
            
            # pull yearly values (named by year)
            vals <- sim$optimized.get(get.instr)
            
            # 5-yr backward ratio: R_t = v_t / v_{t-5}
            R <- vals / dplyr::lag(vals, h)
            
            # 5-yr double-delta at anchor t: DD5_t = R_{t+5} / R_t
            dd5 <- dplyr::lead(R, h) / R
            
            # align to requested years
            dd5 <- dd5[as.character(years)]
            
            # use anchors with both legs present: t in [start+h, end-h]
            use <- years >= (start_year + h) &
                years <= (end_year   - h) &
                is.finite(dd5) & (dd5 > 0)
            
            if (!any(use)) return(if (log) 0 else 1)
            
            dd5 <- dd5[use]
            
            # lognormal band edges on DD5 scale
            lo <- Q25
            hi <- Q75
            
            # make penalty 0 at the band edges
            lp_lo <- dlnorm(lo, meanlog = meanlog, sdlog = sdlog, log = TRUE)
            lp_hi <- dlnorm(hi, meanlog = meanlog, sdlog = sdlog, log = TRUE)
            
            pen <- numeric(length(dd5))
            below <- dd5 < lo
            above <- dd5 > hi
            if (any(below))
                pen[below] <- dlnorm(dd5[below], meanlog = meanlog, sdlog = sdlog, log = TRUE) - lp_lo
            if (any(above))
                pen[above] <- dlnorm(dd5[above], meanlog = meanlog, sdlog = sdlog, log = TRUE) - lp_hi
            # inside [lo, hi] => 0
            
            # inverse-variance weighting
            ivar <- 1 / (sdlog^2)
            w    <- weight * ivar
            
            total.logp <- w * sum(pen, na.rm = TRUE)  # ≤ 0
            if (log) total.logp else exp(total.logp)
        },
        
        get.data.function = function(version, location) {
            sim.meta <- get.simulation.metadata(version = version, location = location)
            
            start_year <- 2013L #'@ryan: we should revise to 2013 so the penalty starts in 2023
            end_year   <- 2030L
            window_len <- 5L
            years <- seq(start_year, end_year)
            
            get.instr <- sim.meta$prepare.optimized.get.instructions(
                outcome                   = "diagnosis.ps",
                dimension.values          = list(year = years),
                keep.dimensions           = "year",
                drop.single.sim.dimension = TRUE
            )
            
            list(
                get.instr   = get.instr,
                years       = years,
                start_year  = start_year,
                end_year    = end_year,
                window_len  = window_len,
                meanlog     = 0.280,   
                sdlog       = 0.630,   # 2*SD [0.3753111-4.66459]
                Q25         = 0.6590209,
                Q75         = 1.879489,
                weight      = PENALTY.WEIGHT
            )
        }
    )


U.turn.strata.likelihood.instructions = create.custom.likelihood.instructions(
    name = "u.turn.strata.5y",
    
    compute.function = function(sim, data, log = TRUE) {
        get.instr  <- data$get.instr
        years      <- data$years
        start_year <- data$start_year
        end_year   <- data$end_year
        h          <- data$window_len        
        meanlog    <- data$meanlog           
        sdlog      <- data$sdlog             
        Q25        <- data$Q25 
        Q75        <- data$Q75         
        weight     <- data$weight
        min_count  <- data$min_count         
        
        # vals: array [year, sex, race]
        vals <- sim$optimized.get(get.instr)
        
        # ensure YEAR is first dimension
        dn <- names(dimnames(vals))
        year_idx <- match("year", dn)
        if (!is.na(year_idx) && year_idx != 1L) {
            ord <- c(year_idx, setdiff(seq_along(dn), year_idx))
            vals <- aperm(vals, ord)
            dn <- dn[ord]
        }
        
        # helper for (sex,race) time series
        per_vec_pen <- function(v, yrs) {
            v   <- as.numeric(v) 
            names(v) <- yrs
            
            # 1y backward ratio and double-delta
            R   <- v / dplyr::lag(v, h)
            dd1 <- dplyr::lead(R, h) / R
            dd1 <- dd1[as.character(yrs)]
            
            # require both legs present and count guardrail on v, v_{t-1}, v_{t+1}
            v_lag  <- dplyr::lag(v, 5)
            v_lead <- dplyr::lead(v, 5)
            use <- yrs >= (start_year + h) &
                yrs <= (end_year   - h) &
                is.finite(dd1) & (dd1 > 0) &
                is.finite(v) & is.finite(v_lag) & is.finite(v_lead) &
                (v >= min_count) & (v_lag >= min_count) & (v_lead >= min_count)
            
            if (!any(use)) return(0)
            dd1 <- dd1[use]
            
            # lognormal band edges on DD1 scale
            lo <- Q25
            hi <- Q75
            lp_lo <- dlnorm(lo, meanlog = meanlog, sdlog = sdlog, log = TRUE)
            lp_hi <- dlnorm(hi, meanlog = meanlog, sdlog = sdlog, log = TRUE)
            
            pen <- numeric(length(dd1))
            below <- dd1 < lo; above <- dd1 > hi
            if (any(below)) pen[below] <- dlnorm(dd1[below], meanlog = meanlog, sdlog = sdlog, log = TRUE) - lp_lo
            if (any(above)) pen[above] <- dlnorm(dd1[above], meanlog = meanlog, sdlog = sdlog, log = TRUE) - lp_hi
            
            sum(pen, na.rm = TRUE)
        }
        
        margin_idx <- match(c("sex","race"), dn, nomatch = 0L)
        margin_idx <- margin_idx[margin_idx > 0L]
        
        total_pen <-
            if (length(margin_idx) == 0L) {
                per_vec_pen(drop(vals), years)
            } else {
                # sum penalties over all sex×race strata
                sum(apply(vals, margin_idx, per_vec_pen, yrs = years), na.rm = TRUE)
            }
        
        # same inverse-variance & weight handling as your original block
        ivar <- 1 / (sdlog^2)
        w    <- weight * ivar
        total.logp <- w * total_pen
        if (log) total.logp else exp(total.logp)
    },
    
    get.data.function = function(version, location) {
        sim.meta <- get.simulation.metadata(version = version, location = location)
        
        start_year <- 2013L    #'@ryan: we should revise to 2013 so the penalty starts in 2023
        end_year   <- 2030L
        window_len <- 5L        
        years <- seq(start_year, end_year)
        
        get.instr <- sim.meta$prepare.optimized.get.instructions(
            outcome                   = "diagnosis.ps",
            dimension.values          = list(year = years),
            keep.dimensions           = c("year","sex","race"),   # key change
            drop.single.sim.dimension = TRUE
        )
        
        list(
            get.instr   = get.instr,
            years       = years,
            start_year  = start_year,
            end_year    = end_year,
            window_len  = window_len,
            meanlog     = 0.280,   
            sdlog       = 0.630,  
            Q25         = 0.6590209,
            Q75         = 1.879489,               
            weight      = PENALTY.WEIGHT,       
            min_count   = 30L                   
        )
    }
)

## EARLY Diagnosis ----
# data from 1941-2022 (cdc.pdf.report) for national model Only (total)
# data from 2000-2023 (cdc.sti) for county; state; national level (total; sex; race; age group; age group+sex; age group + race; race+sex)
# data from 2000-2023 (cdc.sti) for state & national (by race, agegroup, sex)
#
# data from 1993-1999 (cdc.pdf.report) for MSA and national (total)
# data from 1998-2023 for MSA level (cdc.sti) for MSA (total)
# data from 2000-2023 for MSA level (cdc.sti) for MSA (total; sex; race; age group; age group+sex; race+sex; age group+race; age group+race+sex)
#
##---- Overall 1993-2022 ----
# we have modeled the misclassification of EL/LL diagnosis in the model and here we only fit to reported (biased) data
early.diagnosis.total.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.el.misclassified",
                                         outcome.for.data = "early.syphilis.diagnoses", 
                                         levels.of.stratification = c(0),
                                         from.year = 1993,
                                         to.year = 2022,
                                         #
                                         error.variance.type = c('cv', 'sd'),
                                         error.variance.term = list(0.0764791209420945, 10),  
                                         #
                                         observation.correlation.form = 'autoregressive.1',
                                         #
                                         weights = EL.DIAGNOSIS.WEIGHT,  
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1
    )
##---- Strata Stage1 2019-2022 ----
early.diagnosis.by.strata.stage1.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.el.misclassified",
                                         outcome.for.data = "early.syphilis.diagnoses", 
                                         dimensions = c("race","sex"),
                                         levels.of.stratification = c(0,1,2),
                                         from.year = 2019,
                                         to.year = 2022,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.0764791209420945,   
                                         #
                                         observation.correlation.form = 'compound.symmetry',
                                         #
                                         weights = DIAGNOSIS.WEIGHT,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1
    )
##---- Strata Stage2 2019-2022 ----
early.diagnosis.by.strata.stage2.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.el.misclassified",
                                         outcome.for.data = "early.syphilis.diagnoses", 
                                         dimensions = c("age","race","sex"),
                                         levels.of.stratification = c(0,1,2),
                                         from.year = 2019,
                                         to.year = 2022,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.0764791209420945, 
                                         #
                                         observation.correlation.form = 'compound.symmetry',
                                         #
                                         weights = DIAGNOSIS.WEIGHT,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1
    )


## Late/Unknown Diagnosis---- 
# data from 1941-2022 (cdc.pdf.report) for national model Only (total)
# data from 2000-2023 (cdc.sti) for county; state; national level (total; sex; race; age group; age group+sex; age group + race; race+sex)
# data from 2000-2023 (cdc.sti) for state & national (by race, agegroup, sex)
#
# data from 1993-1999 (cdc.pdf.report) for MSA and national (total)
# data from 1998-2023 for MSA level (cdc.sti) for MSA (total)
# data from 2000-2023 for MSA level (cdc.sti) for MSA (total; sex; race; age group; age group+sex; race+sex; age group+race; age group+race+sex)
##---- Overall 1993-2022 ----
late.diagnosis.total.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.late.misclassified", #late latent misclassified + tertiary+cns
                                         outcome.for.data = "unknown.duration.or.late.syphilis.diagnoses", 
                                         levels.of.stratification = c(0),
                                         from.year = 1993,
                                         to.year = 2022,
                                         #
                                         error.variance.type = c('cv', 'sd'),
                                         error.variance.term = list(0.0764791209420945, 10),  
                                         #
                                         observation.correlation.form = 'autoregressive.1',
                                         #
                                         weights = DIAGNOSIS.WEIGHT,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1
                                         
    )
##---- Strata Stage1 2019-2022 ----
late.diagnosis.by.strata.stage1.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.late.misclassified", #late latent misclassified + tertiary+cns
                                         outcome.for.data = "unknown.duration.or.late.syphilis.diagnoses", 
                                         dimensions = c("race","sex"),
                                         levels.of.stratification = c(0,1,2),
                                         from.year = 2019,
                                         to.year = 2022,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.0764791209420945,  
                                         #
                                         observation.correlation.form = 'compound.symmetry',
                                         #
                                         weights = DIAGNOSIS.WEIGHT,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1
    )
##---- Strata Stage2 2019-2022 ----
late.diagnosis.by.strata.stage2.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "diagnosis.late.misclassified", #late latent misclassified + tertiary+cns
                                         outcome.for.data = "unknown.duration.or.late.syphilis.diagnoses", 
                                         dimensions = c("age","race","sex"),
                                         levels.of.stratification = c(0,1,2),
                                         from.year = 2019,
                                         to.year = 2022,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.0764791209420945,  
                                         #
                                         observation.correlation.form = 'compound.symmetry',
                                         #
                                         weights = DIAGNOSIS.WEIGHT,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1
    )

##** HIV TESTS ** ----
##---- Strata Stage1 2014-2019 ----
hiv.testing.by.strata.stage1.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "hiv.testing",
                                         outcome.for.data = "proportion.tested.for.hiv", 
                                         dimensions = c("race","sex"),
                                         levels.of.stratification = c(0,1),
                                         from.year = 2014,
                                         to.year = 2019,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.05,
                                         #
                                         observation.correlation.form = 'compound.symmetry', #short duration of data warrants using the CS
                                         #
                                         weights = TESTING.WEIGHT,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1
    )

##---- Strata Stage2 2014-2019 ----
hiv.testing.by.strata.stage2.likelihood.instructions =
    create.basic.likelihood.instructions(outcome.for.sim = "hiv.testing",
                                         outcome.for.data = "proportion.tested.for.hiv", 
                                         dimensions = c("age","race","sex"),
                                         levels.of.stratification = c(0,1),
                                         from.year = 2014,
                                         to.year = 2019,
                                         #
                                         error.variance.type = 'cv',
                                         error.variance.term = 0.05,
                                         #
                                         observation.correlation.form = 'compound.symmetry', #short duration of data warrants using the CS
                                         #
                                         weights = TESTING.WEIGHT,
                                         equalize.weight.by.year = T,
                                         minimum.error.sd = 1
    )

##** PROPORTION TESTED ** ----
## State-level: for situations where MSA level data is not available 
# need to figure out how to write this for MSM and Heterosexual
SHIELD.DUMMY.PARTITIONING.FUNCTION <- function(arr, version = 'shield', location) {
    # Intentionally do nothing:
    return(arr)
}
proportion.tested.bias.estimates = get.cached.object.for.version(name = "proportion.tested.bias.estimates", 
                                                                 version = 'ehe')
SHIELD.PARTITIONING.FUNCTION <- function(arr, version, location)
{
    # We only do anything if:
    #  (a) there is a "sex" dimension,
    #  (b) both "msm" and "heterosexual_male" are present as sex levels, and
    #  (c) the two male slices are IDENTICAL everywhere (i.e., they are a duplicated slab).
    # This matches the EHE pattern: only redistribute when the two male strata are copies.
    if ("sex" %in% names(dim(arr)) &&
        all(c("msm","heterosexual_male") %in% dimnames(arr)$sex) &&
        all(array.access(arr, sex = "msm") == array.access(arr, sex = "heterosexual_male")))
    {
        # ---- Pull metadata needed by the helper that returns MSM proportions ----
        # specification.metadata informs how to shape (age/race) the MSM proportion array.
        specification.metadata <- get.specification.metadata(version = version, location = location)
        
        # ---- Get best-guess MSM proportions for this location ----
        # keep.age/keep.race tell the helper to return proportions stratified to match 'arr'
        # (only if those dimensions exist). 'ages' pins the age ordering to arr's dimnames.
        # The result 'proportion.msm' is typically an array over year/age/race (subset thereof).
        proportion.msm <- get.best.guess.msm.proportions(
            location,
            specification.metadata = specification.metadata,
            keep.age  = any(names(dim(arr)) == "age"),
            keep.race = any(names(dim(arr)) == "race"),
            ages      = dimnames(arr)$age
        )
        
        # ---- Build a partition array over sex = {msm, heterosexual_male} ----
        # Concatenate p(MSM) and 1 - p(MSM), then give it the same non-sex dimnames as
        # 'proportion.msm', plus a two-level 'sex' dimension ordered c("msm","heterosexual_male").
        sex.partition.arr <- c(as.numeric(proportion.msm), 1 - as.numeric(proportion.msm))
        sex.partition.dimnames <- c(dimnames(proportion.msm), list(sex = c("msm", "heterosexual_male")))
        dim(sex.partition.arr)    <- sapply(sex.partition.dimnames, length)
        dimnames(sex.partition.arr) <- sex.partition.dimnames
        
        # ---- Select the portion of 'arr' that aligns with the partition dims ----
        # This pulls the slab of 'arr' whose dimensions match sex.partition.dimnames.
        sex.modified <- array.access(arr, sex.partition.dimnames)
        
        # ---- Apply the partition to split the duplicated male mass ----
        # expand.array broadcasts the partition over any remaining dims in sex.modified.
        # Multiplying implements: new(msm) = total_male * p_msm; new(hetero) = total_male * (1 - p_msm).
        sex.modified <- sex.modified * expand.array(sex.partition.arr, dimnames(sex.modified))
        
        # ---- Write the modified slab back into the original array ----
        array.access(arr, dimnames(sex.modified)) <- sex.modified
    }
    
    # Return the (possibly) modified array. If the condition above didn't hold,
    # we return 'arr' unchanged (again, matching EHE behavior).
    arr
}
##---- Overall 2010-2019 ---- #@Ryan: please document and explain what's what 
proportion.tested.nested.likelihood.instructions =
    create.nested.proportion.likelihood.instructions(outcome.for.data = "proportion.tested.for.hiv",
                                                     outcome.for.sim = "hiv.testing",
                                                     denominator.outcome.for.data = "adult.population",
                                                     #
                                                     location.types = c('STATE','CBSA'),
                                                     minimum.geographic.resolution.type = 'COUNTY',
                                                     #
                                                     levels.of.stratification = c(0),
                                                     from.year = 2010,
                                                     to.year = 2019,
                                                     #
                                                     p.bias.inside.location = 0,
                                                     p.bias.outside.location = proportion.tested.bias.estimates$out.mean,
                                                     p.bias.sd.inside.location = proportion.tested.bias.estimates$out.sd,
                                                     p.bias.sd.outside.location = proportion.tested.bias.estimates$out.sd,
                                                     #
                                                     within.location.p.error.correlation = 0.5, #Default: correlation from one year to other in the bias in the city and outside the city
                                                     within.location.n.error.correlation = 0.5, #Default: ratio of tests outside MSA to those inside MSA (for MSA we usually dont have fully stratified numbers)
                                                     #
                                                     observation.correlation.form = 'compound.symmetry',
                                                     p.error.variance.type = 'cv',
                                                     p.error.variance.term = 0.5,
                                                     #
                                                     partitioning.function = SHIELD.DUMMY.PARTITIONING.FUNCTION,
                                                     #
                                                     weights = TESTING.WEIGHT,
                                                     equalize.weight.by.year = T
    )


##---- Strata Stage1 2010-2019 ----
proportion.tested.by.strata.stage1.nested.likelihood.instructions =
    create.nested.proportion.likelihood.instructions(outcome.for.data = "proportion.tested.for.hiv",
                                                     outcome.for.sim = "hiv.testing",
                                                     denominator.outcome.for.data = "adult.population",
                                                     #
                                                     location.types = c('STATE','CBSA'),
                                                     minimum.geographic.resolution.type = 'COUNTY',
                                                     #
                                                     dimensions = c("sex","race"),
                                                     levels.of.stratification = c(0,1),
                                                     from.year = 2010,
                                                     to.year = 2019,
                                                     #
                                                     p.bias.inside.location = 0,
                                                     p.bias.outside.location = proportion.tested.bias.estimates$out.mean,
                                                     p.bias.sd.inside.location = proportion.tested.bias.estimates$out.sd,
                                                     p.bias.sd.outside.location = proportion.tested.bias.estimates$out.sd,
                                                     #
                                                     within.location.p.error.correlation = 0.5, #Default: correlation from one year to other in the bias in the city and outside the city
                                                     within.location.n.error.correlation = 0.5, #Default: ratio of tests outside MSA to those inside MSA (for MSA we usually dont have fully stratified numbers)
                                                     #
                                                     observation.correlation.form = 'compound.symmetry',
                                                     p.error.variance.term = 0.5,
                                                     p.error.variance.type = 'cv', 
                                                     #
                                                     partitioning.function = SHIELD.PARTITIONING.FUNCTION,
                                                     #
                                                     weights = (TESTING.WEIGHT),
                                                     equalize.weight.by.year = T
    )
##---- Strata Stage2 2010-2019 ----
proportion.tested.by.strata.stage2.nested.likelihood.instructions =
    create.nested.proportion.likelihood.instructions(outcome.for.data = "proportion.tested.for.hiv",
                                                     outcome.for.sim = "hiv.testing",
                                                     denominator.outcome.for.data = "adult.population",
                                                     #
                                                     location.types = c('STATE','CBSA'),
                                                     minimum.geographic.resolution.type = 'COUNTY',
                                                     #
                                                     dimensions = c("age","sex","race"),
                                                     levels.of.stratification = c(0,1),
                                                     from.year = 2010,
                                                     to.year = 2019,
                                                     #
                                                     p.bias.inside.location = 0,
                                                     p.bias.outside.location = proportion.tested.bias.estimates$out.mean,
                                                     p.bias.sd.inside.location = proportion.tested.bias.estimates$out.sd,
                                                     p.bias.sd.outside.location = proportion.tested.bias.estimates$out.sd,
                                                     #
                                                     within.location.p.error.correlation = 0.5, #Default: correlation from one year to other in the bias in the city and outside the city
                                                     within.location.n.error.correlation = 0.5, #Default: ratio of tests outside MSA to those inside MSA (for MSA we usually dont have fully stratified numbers)
                                                     #
                                                     observation.correlation.form = 'compound.symmetry',
                                                     p.error.variance.term = 0.5,
                                                     p.error.variance.type = 'cv', 
                                                     #
                                                     partitioning.function = SHIELD.PARTITIONING.FUNCTION,
                                                     #
                                                     weights = (TESTING.WEIGHT),
                                                     equalize.weight.by.year = T
    )
##---- State Strata Stage1 ----
state.HIV.tested.by.strata.stage1.likelihood.instructions =
    create.ifelse.likelihood.instructions(
        hiv.testing.by.strata.stage1.likelihood.instructions,
        proportion.tested.by.strata.stage1.nested.likelihood.instructions
    )
##---- State Strata Stage2 ----
state.HIV.tested.by.strata.stage2.likelihood.instructions =
    create.ifelse.likelihood.instructions(
        hiv.testing.by.strata.stage2.likelihood.instructions,
        proportion.tested.by.strata.stage2.nested.likelihood.instructions
    )


#-- LIKELIHOODS --# ----
## STAGE0 ----
lik.inst.demog.TD=join.likelihood.instructions(
    population.likelihood.instructions,
    deaths.likelihood.instructions,
    fertility.likelihood.instructions,
    immigration.likelihood.instructions,
    emigration.likelihood.instructions,
    ps.diagnosis.total.likelihood.instructions,
    total.diagnosis.likelihood.instructions,
    historical.diagnosis.likelihood.instructions
    
)

lik.inst.demog.TD.2=join.likelihood.instructions(
    population.likelihood.instructions,
    deaths.likelihood.instructions,
    fertility.likelihood.instructions,
    immigration.likelihood.instructions,
    emigration.likelihood.instructions,
    ps.diagnosis.total.likelihood.instructions
)

## STAGE1 ----- 
lik.inst.diag.strata.stage1.no.demog.w.future.totals=join.likelihood.instructions(
    total.diagnosis.likelihood.instructions,
    total.diagnosis.by.strata.stage1.likelihood.instructions,
    #
    ps.diagnosis.total.likelihood.instructions,
    ps.diagnosis.by.strata.stage1.likelihood.instructions,
    #
    early.diagnosis.total.likelihood.instructions,
    early.diagnosis.by.strata.stage1.likelihood.instructions,
    #
    late.diagnosis.total.likelihood.instructions,
    late.diagnosis.by.strata.stage1.likelihood.instructions,
    #
    create.ifelse.likelihood.instructions(
        hiv.testing.by.strata.stage1.likelihood.instructions,
        proportion.tested.by.strata.stage1.nested.likelihood.instructions
    ),
    #
    historical.diagnosis.likelihood.instructions,
    #
    future.change.likelihood.instructions,
    future.change.strata.likelihood.instructions,
    #
    U.turn.likelihood.instructions,
    U.turn.strata.likelihood.instructions
)
## STAGE2 ----- 
lik.inst.diag.strata.stage2.no.demog.w.future.totals=join.likelihood.instructions(
    total.diagnosis.likelihood.instructions,
    total.diagnosis.by.strata.stage2.likelihood.instructions,
    #
    ps.diagnosis.total.likelihood.instructions,
    ps.diagnosis.by.strata.stage2.likelihood.instructions,
    # 
    early.diagnosis.total.likelihood.instructions,
    early.diagnosis.by.strata.stage2.likelihood.instructions,
    # 
    late.diagnosis.total.likelihood.instructions,
    late.diagnosis.by.strata.stage2.likelihood.instructions,
    # 
    create.ifelse.likelihood.instructions(
        hiv.testing.by.strata.stage2.likelihood.instructions,
        proportion.tested.by.strata.stage2.nested.likelihood.instructions
    ),
    #
    historical.diagnosis.likelihood.instructions,
    # 
    future.change.likelihood.instructions,
    future.change.strata.likelihood.instructions,
    # 
    U.turn.likelihood.instructions,
    U.turn.strata.likelihood.instructions
)


